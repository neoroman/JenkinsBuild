###############################################################################
### Functions START ###########################################################
###############################################################################
function getPrefixOnly() {
  testString="${GIT_TAG_FULL}"
  if test ! -z "$1"; then
    testString="$1"
  fi
  onlyPrefixString="$(echo "${testString}" | tr -d '[0-9]._()' | tr '[:lower:]' '[:upper:]')"
  if test ! -z "${onlyPrefixString}"; then
    BUILD_TYPE="${onlyPrefixString}"
  fi
}
function getVersionOnly() {
  testString="${GIT_TAG_FULL}"
  if test ! -z "$1"; then
    testString="$1"
  fi
  onlyVersionString="$(echo "${testString}" | tr -d '[A-Za-z]-')"
  if test ! -z "${onlyVersionString}"; then
    VERSIONS="${onlyVersionString}"
  fi
}
function getParsedVersion() {
  testString="${VERSIONS}"
  if test ! -z "$1"; then
    testString="$1"
  fi
  if test ! -z "${testString}"; then
    VERSION_STRING=( ${testString//./ })
    MAJOR="$(echo ${VERSION_STRING[0]} | tr -d '()._-')"
    MINOR="$(echo ${VERSION_STRING[1]} | tr -d '()._-')"
    POINT="$(echo ${VERSION_STRING[2]} | sed -e 's/\(.*\)[(_.].*/\1/')"
    if test ! -z "$1"; then
      echo "${MAJOR}.${MINOR}.${POINT}"
    else
      MARKET_VERSION="${MAJOR}.${MINOR}.${POINT}"
      BUILD_NUMBER="${VERSION_STRING[3]}"
    fi
    if test -z "${BUILD_NUMBER}"; then
      VERSION_STRING=( ${VERSIONS//(/ })
      if test -z "$1"; then
        BUILD_NUMBER="$(echo ${VERSION_STRING[1]} | tr -d '()._-')"
      fi
    fi
  fi
}
function getLastTag() {
  LAST_FULL_TAG=$(git describe --tags --abbrev=0)
  getPrefixOnly ${LAST_FULL_TAG}
  getVersionOnly ${LAST_FULL_TAG}
  LAST_BUILD_TYPE="${BUILD_TYPE}"
  LAST_TAG="${VERSIONS}"
}
function getConfigPrefix() {
  if [ $USING_CONFIG -eq 1 ]; then
    tempOS="${INPUT_OS}"
    if [[ "$INPUT_OS" == "both" ]]; then
      tempOS="android"
    fi
    TAG_PREFIX="$(git config -f $CONFIG_FILE --get "${tempOS}.tagPrefix.${RELEASE_TYPE}")"
  fi
}
function getInputTag() {
  getVersionOnly
  if [ $USING_CONFIG -eq 1 ]; then
    getConfigPrefix
    upperGitFullTag="$(echo ${GIT_TAG_FULL} | tr '[:lower:]' '[:upper:]')"
    if [[ "${upperGitFullTag}" == "${TAG_PREFIX}"* ]]; then
      BUILD_TYPE="${TAG_PREFIX}"
    elif [[ "${VERSIONS}" == "${GIT_TAG_FULL}" ]]; then
      BUILD_TYPE="${TAG_PREFIX}"
    else
      printInputTag
      printUncorrectTagPrefixError
      exit
    fi
  else
    getPrefixOnly
  fi
  getParsedVersion
  FINAL_TAG="${BUILD_TYPE}${VERSIONS}"
}
function printLastTag() {
  getLastTag
  if test -n "$LAST_FULL_TAG"; then
    echo "  ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑"
    echo "       FYI - The last tag is '${LAST_FULL_TAG}'"
    echo "  ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙"
  fi
}
function printInputTag() {
  echo " ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑"
  echo "     Input tag is '${GIT_TAG_FULL}'"
  echo "     Input platform is '${INPUT_OS}'"
  echo "     Input release type is '${RELEASE_TYPE}'"
  if test ! -z "$CONFIG_FILE"; then
    if test -f "$CONFIG_FILE"; then
      echo "     Input config file is '${CONFIG_FILE}'"
      echo "     Parsed tag prefix is '${TAG_PREFIX}'" 
    fi
  fi
  if [ $DRY_RUN -eq 1 ]; then
    echo "     Is dry-run? ........................[YES]"
  fi
  echo " ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙"
}
function printResult() {
  echo " ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑"
  echo "     Result - Jenkins build as tag '$FINAL_TAG' started..."
  echo " ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙"
}
function printUntrackError() {
  echo " ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑"
  echo "     There are some issues, maybe untracked files remained..."
  echo "     You can 'git stash' untracked files for push!"
  echo " ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙"
}
function printNotMainError() {
  echo " ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑"
  echo "     Branch is not 'main', you should checkout main branch"
  echo " ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙"
}
function printUncommitError() {
  echo " ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑"
  echo "     WARNING: There are some issues, maybe uncommited files remained..."
  echo "            run git commit first..."
  echo " ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙"
}
function printUncorrectTagPrefixError() {
  echo " ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑"
  echo "     Error: syntax of input tag according to $CONFIG_FILE"
  echo "          Input tag should be '${TAG_PREFIX}${VERSIONS}', not '${GIT_TAG_FULL}'"
  echo " ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙"
}
function printGradleVersionNameError() {
  getLastTag
  currentTagVersion=$(getParsedVersion "${LAST_TAG}")
  GRADLE_VERSION=$(echo "${oldVersionName}" | tr -d ' ')
  echo " ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑"
  echo "     Error: abnormal 'versionName' in $AOS_FILE"
  echo "          Current 'versionName' should be '${currentTagVersion}', not '${GRADLE_VERSION}'"
  echo "          Check your $AOS_FILE"
  echo " ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙"
}
function printNoDistConfigWarning() {
  echo " WARNING: dist.config not exist in $PWD"
  echo "        cp $SCRIPT_PATH/dist.config.default dist.config"
}
function matchPlatformOrNot() {
  trap "$(shopt -p nocasematch 2>/dev/null)" RETURN 2>/dev/null || true
  shopt -s nocasematch 2>/dev/null || true
  case "${INPUT_OS}" in
    "android" ) INPUT_OS="android";;
    "ios" ) INPUT_OS="ios";;
    "both" ) INPUT_OS="both";;
    "unknown" )
      echo "  [$SCRIPT_NAME] 경고: 플랫폼이 지정되지 않았습니다. (-p 옵션 없음)"
      INPUT_OS="both"
      ;;
    * )
      $SCRIPT_PATH/$SCRIPT_NAME -h
      echo "Error: unknown platform was specified => ${INPUT_OS}."
      echo ""
      exit
      ;;
  esac
}
function matchReleaseTypeOrNot() {
  # thanks to https://stackoverflow.com/a/50808490
  trap "$(shopt -p nocasematch)" RETURN
  # thanks to https://stackoverflow.com/a/1728814
  shopt -s nocasematch
  case "${RELEASE_TYPE}" in
    "release" ) RELEASE_TYPE="release";;
    "develop" ) RELEASE_TYPE="develop";;
    * ) 
      $SCRIPT_PATH/$SCRIPT_NAME -h
      echo "Error: unknown release type was specified => ${RELEASE_TYPE}."
      echo ""
      exit
      ;;
  esac
}
function parsingPrefixAndDeclare() {
  tmpConfigFile=""
  if test -f "${CONFIG_FILE}"; then
    tmpConfigFile="${CONFIG_FILE}"
  elif test -f "dist.config"; then
    # TODO: guess how to config without dist.config...
    tmpConfigFile="dist.config"
  fi

  if test -f "${tmpConfigFile}"; then
    if [[ "${GIT_TAG_FULL}" == [A-Za-z]* ]]; then
      iosReleaseTagPrefix="$(git config -f ${tmpConfigFile} --get "ios.tagPrefix.release" | tr '[:lower:]' '[:upper:]')"
      aosReleaseTagPrefix="$(git config -f ${tmpConfigFile} --get "android.tagPrefix.release" | tr '[:lower:]' '[:upper:]')"
      tmpOS="${INPUT_OS}"
      if [[ "${tmpOS}" == "both" ]]; then
        tmpOS="android"
      fi
      developTagPrefix="$(git config -f ${tmpConfigFile} --get "${tmpOS}.tagPrefix.develop" | tr '[:lower:]' '[:upper:]')"
      getPrefixOnly
      if [[ "${BUILD_TYPE}" == "${iosReleaseTagPrefix}" ]]; then
        RELEASE_TYPE="release"
        INPUT_OS="ios"
        TAG_PREFIX="${BUILD_TYPE}"
        CONFIG_FILE="${tmpConfigFile}"
        USING_CONFIG=1
      elif [[ "${BUILD_TYPE}" == "${aosReleaseTagPrefix}" ]]; then
        RELEASE_TYPE="release"
        INPUT_OS="android"
        TAG_PREFIX="${BUILD_TYPE}"
        CONFIG_FILE="${tmpConfigFile}"
        USING_CONFIG=1
      elif [[ "${BUILD_TYPE}" == "${developTagPrefix}" ]]; then
        RELEASE_TYPE="develop"
        TAG_PREFIX="${BUILD_TYPE}"
        CONFIG_FILE="${tmpConfigFile}"
        USING_CONFIG=1
      fi
      if [[ "$(git config -f ${tmpConfigFile} --get "version.autoUpdate")" == "true" ]]; then
        UPDATE_VERSION=1
      else
        UPDATE_VERSION=0
      fi
    fi
  elif test ! -f "dist.config"; then
    printNoDistConfigWarning
  fi
}
function spinner() {
    local i sp n
    sp='/-\|'
    n=${#sp}
    printf '  Wait a moment... '
    while sleep 0.1; do
        printf "%s\b" "${sp:i++%n:1}"
    done
}
function show_spinner() {
    tput civis #hide cursor
    spinner &
    spinner_pid=$!
}
function hide_spinner() {
  if test ! -z "$spinner_pid"; then
    kill $spinner_pid 2>/dev/null || true
    wait $spinner_pid 2>/dev/null || true
    unset spinner_pid
    tput cnorm #show cursor
    echo -e "\033[1K" # remove echoed one line
  fi
}
function confirm() {
  local message="$1"
  if [ "${NON_INTERACTIVE:-0}" -eq 1 ]; then
    echo "  [$SCRIPT_NAME] $message (y/n): y [auto-confirmed]"
    return 0
  fi
  while true; do
    read -rp "  [$SCRIPT_NAME] $message (y/n): " answer
    case "$answer" in
      [Yy]*) return 0;;
      [Nn]*) return 1;;
      *) echo "  [$SCRIPT_NAME] Please answer yes (y) or no (n).";;
    esac
  done
}
function checkVersionUpdate() {
  local parsedTagVersion="$1"
  local currentVersion="$2"
  local platform="$3"
  if [ "${UPDATE_VERSION_FORCE:-0}" -eq 1 ]; then
    return 0
  fi
  local versionComparison
  versionComparison=$(vercomp "$parsedTagVersion" "$currentVersion")
  if [ "$versionComparison" -ge 2 ]; then
    echo "  [$SCRIPT_NAME] $platform: 새 버전($parsedTagVersion)이 현재 버전($currentVersion)보다 낮습니다."
    return 1
  fi
  return 0
}
function shouldUpdateVersion() {
  local HAS_IOS_FILE HAS_AOS_FILE SHOULD_UPDATE=0
  local parsedTagVersion versionPart
  versionPart=$(echo "${GIT_TAG_FULL}" | tr -d '[A-Za-z]-')
  parsedTagVersion=$(echo "$versionPart" | awk -F. '{print $1"."$2"."$3}')
  HAS_IOS_FILE=$(find . -name 'project.pbxproj' -not -path "*/Pods/*" -not -path "*/node_modules/*" -print -quit 2>/dev/null)
  HAS_AOS_FILE=$(find . -name 'build.gradle' -exec grep -l 'com.android.application' {} + 2>/dev/null | grep -v 'node_modules' | head -n 1)
  if [ -z "$HAS_IOS_FILE" ] && [ -z "$HAS_AOS_FILE" ]; then
    return 1
  fi
  if [ -n "$HAS_IOS_FILE" ]; then
    oldMarketingVersion=$(grep 'MARKETING_VERSION =' "$HAS_IOS_FILE" | awk '{print $3}' | tr -d ';' | head -n 1)
    if [ -n "$oldMarketingVersion" ]; then
      checkVersionUpdate "$parsedTagVersion" "$oldMarketingVersion" "iOS" && SHOULD_UPDATE=1
    fi
  fi
  if [ -n "$HAS_AOS_FILE" ]; then
    oldVersionName=$(grep 'versionName' "$HAS_AOS_FILE" | awk -F'"' '{print $2}' | head -n 1)
    if [ -n "$oldVersionName" ]; then
      checkVersionUpdate "$parsedTagVersion" "$oldVersionName" "Android" && SHOULD_UPDATE=1
    fi
  fi
  [ "$SHOULD_UPDATE" -eq 1 ]
  return $?
}
function loadJenkinsConfig() {
  local cfg="${1:-$CONFIG_FILE}"
  if [ -f "$cfg" ]; then
    JENKINS_URL=$(git config -f "$cfg" --get "jenkins.url" 2>/dev/null || true)
    JENKINS_JOB_NAME=$(git config -f "$cfg" --get "jenkins.job" 2>/dev/null || true)
    JENKINS_USER=$(git config -f "$cfg" --get "jenkins.user" 2>/dev/null || true)
    JENKINS_TOKEN=$(git config -f "$cfg" --get "jenkins.token" 2>/dev/null || true)
  fi
  if [ -f "dist.config" ] && [ -z "$JENKINS_URL" ]; then
    JENKINS_URL=$(git config -f "dist.config" --get "jenkins.url" 2>/dev/null || true)
    JENKINS_JOB_NAME=$(git config -f "dist.config" --get "jenkins.job" 2>/dev/null || true)
    JENKINS_USER=$(git config -f "dist.config" --get "jenkins.user" 2>/dev/null || true)
    JENKINS_TOKEN=$(git config -f "dist.config" --get "jenkins.token" 2>/dev/null || true)
  fi
}
function downloadJenkinsCLI() {
  local url="$1" jarFile="$2"
  local maxAge=86400 tempFile
  tempFile="/tmp/jenkins-cli-${RANDOM}-$$.jar.tmp"
  if [ -f "$jarFile" ]; then
    fileAge=$(($(date +%s) - $(date -r "$jarFile" +%s 2>/dev/null || echo 0)))
    if [ "$fileAge" -lt "$maxAge" ]; then
      echo "  [$SCRIPT_NAME] Using existing Jenkins CLI jar (age: $((fileAge/3600)) hours)"
      return 0
    fi
  fi
  if [ "$DRY_RUN" -eq 1 ]; then
    echo "  [$SCRIPT_NAME] DRY-RUN: Would download $url/jnlpJars/jenkins-cli.jar"
    return 0
  fi
  show_spinner
  if curl -sSfL --connect-timeout 10 --max-time 60 -o "$tempFile" "$url/jnlpJars/jenkins-cli.jar" 2>/dev/null; then
    hide_spinner
    if file "$tempFile" 2>/dev/null | grep -q "Java archive data"; then
      mv "$tempFile" "$jarFile"
      echo "  [$SCRIPT_NAME] Downloaded Jenkins CLI successfully."
      return 0
    fi
    rm -f "$tempFile"
  else
    hide_spinner
    rm -f "$tempFile"
  fi
  echo "  [$SCRIPT_NAME] ERROR: Failed to download Jenkins CLI jar."
  return 1
}
function triggerJenkinsBuild() {
  local url="$1" jobName="$2" jarFile="$3"
  echo "  [$SCRIPT_NAME] Triggering Jenkins build for job '$jobName'..."
  if [ -z "$JENKINS_USER" ] || [ -z "$JENKINS_TOKEN" ]; then
    if [ "${NON_INTERACTIVE:-0}" -eq 1 ]; then
      echo "  [$SCRIPT_NAME] ERROR: Jenkins credentials required in config for non-interactive mode (-y)."
      exit 1
    fi
    read -rp "  [$SCRIPT_NAME] Jenkins 사용자 ID를 입력하세요: " JENKINS_USER
    read -rsp "  [$SCRIPT_NAME] Jenkins 토큰을 입력하세요: " JENKINS_TOKEN
    echo
  fi
  if [ "$DRY_RUN" -eq 1 ]; then
    echo "  [$SCRIPT_NAME] DRY-RUN: Would trigger Jenkins build $jobName"
    return 0
  fi
  show_spinner
  if java -jar "$jarFile" -s "$url/" -auth "$JENKINS_USER:$JENKINS_TOKEN" build "$jobName"; then
    hide_spinner
    echo "  [$SCRIPT_NAME] Jenkins build triggered successfully."
  else
    hide_spinner
    echo "  [$SCRIPT_NAME] ERROR: Failed to trigger Jenkins build."
    exit 1
  fi
}
function makeConfig() {
  local configFile="dist.config"
  echo "  [$SCRIPT_NAME] 설정 파일 생성을 시작합니다..."
  if [ -f "$configFile" ]; then
    if ! confirm "설정 파일이 이미 존재합니다. 덮어쓰시겠습니까?"; then
      echo "  [$SCRIPT_NAME] 설정 파일 생성이 취소되었습니다."
      exit 0
    fi
  fi
  cp "$SCRIPT_PATH/dist.config.default" "$configFile" 2>/dev/null || true
  if [ ! -f "$configFile" ]; then
    cat > "$configFile" << 'DEF'
[ios "tagPrefix"]
	develop = D-
	release = RI-
[android "tagPrefix"]
	release = RA-
	develop = D-
[version]
	autoUpdate = true
[jenkins]
	url =
	job =
	user =
	token =
DEF
  else
    if ! grep -q '\[jenkins\]' "$configFile" 2>/dev/null; then
      cat >> "$configFile" << 'DEF'

[jenkins]
	url =
	job =
	user =
	token =
DEF
    fi
  fi
  read -rp "  [$SCRIPT_NAME] Jenkins URL을 입력하세요 (선택사항, Enter 스킵): " jenkinsUrl || true
  read -rp "  [$SCRIPT_NAME] Jenkins Job 이름을 입력하세요 (선택사항): " jenkinsJob || true
  read -rp "  [$SCRIPT_NAME] Jenkins 사용자 ID를 입력하세요 (선택사항): " jenkinsUser || true
  read -rsp "  [$SCRIPT_NAME] Jenkins API 토큰을 입력하세요 (선택사항): " jenkinsToken || true
  echo
  if [ -n "$jenkinsUrl" ]; then
    git config -f "$configFile" jenkins.url "$jenkinsUrl"
  fi
  if [ -n "$jenkinsJob" ]; then
    git config -f "$configFile" jenkins.job "$jenkinsJob"
  fi
  if [ -n "$jenkinsUser" ]; then
    git config -f "$configFile" jenkins.user "$jenkinsUser"
  fi
  if [ -n "$jenkinsToken" ]; then
    git config -f "$configFile" jenkins.token "$jenkinsToken"
  fi
  echo "  [$SCRIPT_NAME] 설정 파일이 생성되었습니다: $configFile"
  exit 0
}
function help() {
    echo ""
    echo "Usage: $SCRIPT_NAME --make-config"
    echo "       $SCRIPT_NAME [ -t | --tag <tag name>] [ -p | --platform {ios|android|both}] "
    echo "          [ -c | --config <config_file>] [ -r | --release-type {release|develop}] "
    echo "          [ -a | --auto-update] [ -uf | --force-update] [ -y | --yes] [ --dry-run]"
    echo "          [ --jenkins-url <url>] [ --jenkins-job <job>] [ --jenkins-user <user>] [ --jenkins-token <token>]"
    echo ""
    echo "Examples:"
    echo "       $SCRIPT_NAME -t '1.0.0.123'"
    echo "       $SCRIPT_NAME -t '1.0.0.123' -p ios -a -r release -y"
    echo "       $SCRIPT_NAME -t '1.0.0.123' -c dist.config -a"
    echo "       $SCRIPT_NAME -t '1.0.0.123' -c dist.config -a --dry-run"
    echo "       $SCRIPT_NAME -t 'D-1.0.0.123' -a --jenkins-url http://jenkins.local --jenkins-job my-job -y"
    echo ""
    echo "Mandatory arguments:"
    echo "   -t, --tag          git tag to be added with <tag name: Major.Minor.Point.Build> such like followings:"
    echo "                        eg. tag prefix 'D-1.0.0' means test build for both iOS and Android platform"
    echo "                        eg. tag prefix 'RA-4.1.3.777' means release build for Android platform"
    echo "                        eg. tag prefix 'RI-7.2.9.450' means release build for iOS platform"
    echo ""
    echo "Optional arguments:"
    echo "   -h, --help         show this help message and exit"
    echo "   --make-config     create dist.config interactively"
    echo "   -c, --config       <config_file>"
    echo "                      can copy file from $SCRIPT_PATH/dist.config.default"
    echo "   -p, --platform     {ios|android|both}, default is both"
    echo "                      assign platform as iOS or Android or both to processing"
    echo "                      warning: this option will be ignored if dist.config given!"
    echo "   -r, --release-type {release|develop}, default is develop"
    echo "                      warning: this option will be ignored if dist.config given!"
    echo "   -a, --auto-update  update project version string(code) in project. and commit & push automatically"
    echo "                      warning: this option will be ignored if dist.config given!"
    echo "   -uf, --force-update  skip version check and force update (use with -a)"
    echo "   -y, --yes          non-interactive: auto-confirm all prompts"
    echo "   --dry-run          dry run only instead of real processing with git command"
    echo "   --jenkins-url      Jenkins server URL (or set in dist.config [jenkins] url)"
    echo "   --jenkins-job      Jenkins job name"
    echo "   --jenkins-user     Jenkins user ID"
    echo "   --jenkins-token    Jenkins API token"
    echo ""
    echo "Example of config file: (git config style)"
    # thanks to ascii from https://en.wikipedia.org/wiki/Box-drawing_character
    echo "   ┌─────── dist.config ───────────┐"
    cat $SCRIPT_PATH/dist.config.default | sed -e 's/^\(.*\)$/      \1/g'
    echo "   └───────────────────────────────┘"
    echo ""
    printLastTag
    echo ""
    echo "Full documentation <https://github.com/neoroman/JenkinsBuild/wiki/dist.sh#full-documentation-for-distsh>"
}
function checkArgumentsAndCope() {
  if test -z "$GIT_TAG_FULL"; then
    $SCRIPT_PATH/$SCRIPT_NAME -h
    if test ! -z "$LAST_FULL_TAG"; then
        echo ""
        echo "Error: no tag name specified."
        echo ""
    fi
    exit
  fi
  if test ! -z "$INPUT_OS"; then
      matchPlatformOrNot
  else
      INPUT_OS="both"
  fi
  if test ! -z "$CONFIG_FILE"; then
      if test ! -f "$CONFIG_FILE"; then
        $SCRIPT_PATH/$SCRIPT_NAME -h
        echo ""
        echo "Error: no config file in $CONFIG_FILE"
        echo ""
        exit
      fi

      USING_CONFIG=1
  fi
  if test ! -z "$RELEASE_TYPE"; then
      matchReleaseTypeOrNot
      parsingPrefixAndDeclare # handle with dist.config
  else
      # Set default release type as develop
      RELEASE_TYPE="develop"
      parsingPrefixAndDeclare # handle with dist.config
  fi
}
###############################################################################
### Functions E N D ###########################################################
###############################################################################